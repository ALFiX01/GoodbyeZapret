import json
import argparse
import sys
import os
from pathlib import Path

# --- Конфигурация ---
VERSION = "1.5.3"

CONFIG_FILE = "strategies.json"
OUTPUT_BAT = "ConfiguratorFix.bat"
OUTPUT_REL_PATH = "../../configs/Custom"

CONFIG_FILE_Z1 = "strategiesZ1.json"
CONFIG_FILE_Z2 = "strategiesZ2.json"
PORTS_BAT = "ports.bat"

# Сопоставление аргументов CLI -> ключи JSON
SERVICE_MAP = {
    "youtube": "YouTube",
    "youtubegooglevideo": "YouTubeGoogleVideo",
    "youtubequic": "YouTubeQuic",
    "twitch": "Twitch",
    "discordupdate": "DiscordUpdate",
    "discordquic": "DiscordQuic",
    "discord": "Discord",
    "discordmedia": "DiscordMedia",
    "blacklist": "Blacklist",
    "cdn": "CDN",
    "amazontcp": "AmazonTCP",
    "amazonudp": "AmazonUDP",
    "custom": "Custom",
    "auto": "AutoHostlist",
    "stun": "STUN"
}

# --- ШАБЛОНЫ БАТНИКА ---

BATCH_HEADER = r"""@echo off
setlocal EnableExtensions
cd /d "%~dp0"

goto :Preparing
:Zapusk
cls

echo                         ______                ____            _____                         __ 
echo                        / ____/___  ____  ____/ / /_  __  ____/__  /  ____ _____  ________  / /_
echo                       / / __/ __ \/ __ \/ __  / __ \/ / / / _ \/ /  / __ `/ __ \/ ___/ _ \/ __/
echo                      / /_/ / /_/ / /_/ / /_/ / /_/ / /_/ /  __/ /__/ /_/ / /_/ / /  /  __/ /_ 
echo                      \____/\____/\____/\__,_/_.___/\__, /\___/____/\__,_/ .___/_/   \___/\__/
echo                                                   /____/               /_/

:: Пути указываем относительно папки configs
for %%I in ("%~dp0..\..") do set "ProjectDir=%%~fI"
set "FAKE=%ProjectDir%\bin\fake\"
set "BIN=%ProjectDir%\bin\"
set "LISTS=%ProjectDir%\%lists\"
cd /d "%BIN%"
"""

BATCH_INFO_TEMPLATE = r"""set "CDN_BypassLevel={cdn_level}"

if not defined tcp_ports set "tcp_ports={tcp_ports_value}"
if not defined udp_ports set "udp_ports={udp_ports_value}"

set "CONFIG_NAME=ConfiguratorFix"
echo Config: %CONFIG_NAME%
title GoodbyeZapret:  %CONFIG_NAME%
echo.
echo Winws:

:: --- Generated by builder.exe v{version} ---
"""

BATCH_TRAY = r"""
REM Проверяем, существует ли GoodbyeZapretTray.exe перед запуском
if exist "%ProjectDir%\tools\tray\GoodbyeZapretTray.exe" (
    tasklist /FI "IMAGENAME eq GoodbyeZapretTray.exe" 2>NUL | find /I /N "GoodbyeZapretTray.exe" >NUL
    if errorlevel 1 (
        start "" "%ProjectDir%\tools\tray\GoodbyeZapretTray.exe"
    )
)

goto :EOF
"""

BATCH_PREPARING = r"""
:Preparing
if not "%1"=="am_admin" (
  powershell -Command "Start-Process -FilePath '%~f0' -ArgumentList 'am_admin' -Verb RunAs"
  exit /b
)
Echo Preparing...

REM Check if winws.exe is running and terminate it if found
tasklist /FI "IMAGENAME eq winws.exe" 2>NUL | find /I /N "winws.exe" >NUL
if "%ERRORLEVEL%"=="0" (
  REM Forcefully kill winws.exe process
  taskkill /F /IM winws.exe >nul 2>&1
)

REM Check if winws2.exe is running and terminate it if found
tasklist /FI "IMAGENAME eq winws2.exe" 2>NUL | find /I /N "winws2.exe" >NUL
if "%ERRORLEVEL%"=="0" (
  REM Forcefully kill winws2.exe process
  taskkill /F /IM winws2.exe >nul 2>&1
)

REM Flush DNS cache
ipconfig /flushdns > nul
cls
goto :Zapusk
"""


def get_base_path():
    if getattr(sys, 'frozen', False):
        return Path(sys.executable).parent
    else:
        return Path(__file__).parent


def load_config(engine="1"):
    file_name = CONFIG_FILE_Z2 if engine == "2" else CONFIG_FILE_Z1
    path = get_base_path() / file_name

    # Для отладки в батнике выведем, какой файл используется
    print(f'set "FILE_USED={file_name}"')

    if not path.exists():
        return {"services": {}, "prefix_rules": []}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"REM [ERROR] Failed to load {file_name}: {e}")
        return {"services": {}, "prefix_rules": []}


def export_limits(data):
    services = data.get("services", {})
    for svc_name, strategies in services.items():
        count = len(strategies)
        print(f'set "MAX_{svc_name}={count}"')


def save_user_config(args, tcp_ports_value="", udp_ports_value=""):
    """
    Сохраняет настройки:
    1. Параметры CLI -> %USERPROFILE%\AppData\Roaming\GoodbyeZapret\configurator.txt
    2. GoodbyeZapret_Config -> %USERPROFILE%\AppData\Roaming\GoodbyeZapret\config.txt
    """
    appdata = os.getenv('APPDATA')
    if not appdata:
        return

    config_dir = Path(appdata) / "GoodbyeZapret"

    if not config_dir.exists():
        try:
            config_dir.mkdir(parents=True, exist_ok=True)
        except:
            return

    # === 1. Работа с configurator.txt (Остальные настройки) ===
    file_configurator = config_dir / "configurator.txt"
    config_data = {}

    # Читаем существующий configurator.txt
    if file_configurator.exists():
        try:
            with open(file_configurator, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if "=" in line:
                        key, value = line.split("=", 1)
                        config_data[key.strip()] = value.strip()
        except Exception as e:
            print(f"REM [WARNING] Failed to read configurator.txt: {e}")

    # Обновляем данные (Короткие ключи)
    updates = {
        "ENGN": args.engine,
        "YT": args.youtube,
        "YTGV": args.youtubegooglevideo,
        "YTQ": args.youtubequic,
        "TW": args.twitch,
        "DS": args.discord,
        "DSUPD": args.discordupdate,
        "DSQ": args.discordquic,
        "DSMEDIA": args.discordmedia,
        "BL": args.blacklist,
        "CDN": args.cdn,
        "AMZTCP": args.amazontcp,
        "AMZUDP": args.amazonudp,
        "CUSTOM": args.custom,
        "Auto": args.auto,
        "STUN": args.stun,
        "CDN_LVL": args.cdn_level
    }

    for key, val in updates.items():
        config_data[key] = f'"{val}"'

    # tcp/udp ports are no longer stored in configurator.txt
    if "tcp_ports" in config_data:
        del config_data["tcp_ports"]
    if "udp_ports" in config_data:
        del config_data["udp_ports"]

    # УБИРАЕМ GoodbyeZapret_Config из configurator.txt, если он там был (переезд на config.txt)
    if "GoodbyeZapret_Config" in config_data:
        del config_data["GoodbyeZapret_Config"]

    # Записываем configurator.txt
    try:
        with open(file_configurator, "w", encoding="utf-8") as f:
            for key, value in config_data.items():
                f.write(f"{key}={value}\n")
    except Exception as e:
        print(f"REM [ERROR] Failed to save configurator.txt: {e}")

    # === 2. Работа с config.txt (Только GoodbyeZapret_Config) ===
    file_config = config_dir / "config.txt"
    main_config_data = {}

    # Читаем существующий config.txt (чтобы не затереть другие настройки пользователя, если есть)
    if file_config.exists():
        try:
            with open(file_config, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if "=" in line:
                        key, value = line.split("=", 1)
                        main_config_data[key.strip()] = value.strip()
        except Exception as e:
            print(f"REM [WARNING] Failed to read config.txt: {e}")

    # Устанавливаем нужное значение
    main_config_data["GoodbyeZapret_Config"] = '"ConfiguratorFix"'

    # Записываем config.txt
    try:
        with open(file_config, "w", encoding="utf-8") as f:
            for key, value in main_config_data.items():
                f.write(f"{key}={value}\n")
    except Exception as e:
        print(f"REM [ERROR] Failed to save config.txt: {e}")

    # === 3. ports.bat (tcp/udp) ===
    file_ports = config_dir / PORTS_BAT
    try:
        with open(file_ports, "w", encoding="utf-8") as f:
            f.write(f'set "tcp_portsV={tcp_ports_value}"\n')
            f.write(f'set "udp_portsV={udp_ports_value}"\n')
    except Exception as e:
        print(f"REM [ERROR] Failed to save {PORTS_BAT}: {e}")


def fix_zapret_rule(rule):
    """
    Исправляет синтаксис аргументов zapret для загрузки файлов.
    Меняет конструкцию --arg="@путь" на --arg=@"путь"
    """
    if not rule:
        return rule
    # Заменяем все вхождения ="@ на =@"
    return rule.replace('="@', '=@"')


def is_blob_rule(rule: str) -> bool:
    if not rule:
        return False
    s = fix_zapret_rule(rule).lstrip()
    # Важно: ловим только отдельный аргумент --blob=..., а не "blob=" внутри lua-desync
    return s.startswith("--blob=") or s.startswith("--blob:")


def is_filter_profile(rule: str) -> bool:
    """
    Определяет, является ли правило фильтровым профилем (строка, где требуется --new).
    ВАЖНО: добавлен --filter-l7= (в т.ч. для stun).
    """
    if not rule:
        return False
    s = rule.lstrip()
    return (
            s.startswith("--filter-tcp=") or
            s.startswith("--filter-udp=") or
            s.startswith("--filter-l3=") or
            s.startswith("--filter-l7=") or
            s.startswith("--filter-ssid=") or
            s.startswith("--ipset=") or
            s.startswith("--ipset-ip=") or
            s.startswith("--ipset-exclude=") or
            s.startswith("--ipset-exclude-ip=")
    )


def generate_bat_file(args, data):
    services_config = data.get("services", {})
    prefix_rules = data.get("prefix_rules", [])

    main_rules = []
    stun_rules = []

    for arg_name, json_key in SERVICE_MAP.items():
        choice = getattr(args, arg_name, "0")
        if choice == "0":
            continue

        strategies = services_config.get(json_key, {})
        selected_rules = strategies.get(choice)

        if not selected_rules:
            continue

        if "STUN" in json_key:
            stun_rules.extend(selected_rules)
        else:
            main_rules.extend(selected_rules)

    # ==========================================
    # Один EXE на весь батник по движку
    # ==========================================
    target_exe = "winws2.exe" if args.engine == "2" else "winws.exe"

    # ==========================================
    # STUN -> в общий список (один процесс winws*)
    # Ставим STUN-правила в начало, чтобы они были отдельными профилями раньше остальных.
    # ==========================================
    all_rules = stun_rules + main_rules

    # ==========================================
    # УДАЛЕНИЕ ДУБЛИКАТОВ (для всех правил)
    # ==========================================
    seen = set()
    unique_rules = []
    for rule in all_rules:
        if rule not in seen:
            unique_rules.append(rule)
            seen.add(rule)
    all_rules = unique_rules

    # ==========================================
    # ГРУППИРУЕМ ВСЕ --blob В ОДИН БЛОК (сверху)
    # ==========================================
    blob_rules = [r for r in all_rules if is_blob_rule(r)]
    other_rules = [r for r in all_rules if not is_blob_rule(r)]
    all_rules = blob_rules + other_rules

    # --- НОВЫЙ КОД: извлечение портов и подстановка в префиксные правила ---
    def extract_ports_from_rules(rules, proto):
        """Извлекает порты и диапазоны из правил с --filter-{proto}="""
        ports = set()
        ranges = set()
        pattern = f'--filter-{proto}='
        for rule in rules:
            if not isinstance(rule, str):
                continue
            start = 0
            while start < len(rule):
                idx = rule.find(pattern, start)
                if idx == -1:
                    break
                start_val = idx + len(pattern)

                # Определяем конец значения аргумента (до пробела или конца строки)
                end_val = rule.find(' ', start_val)
                if end_val == -1:
                    value = rule[start_val:].strip()
                else:
                    value = rule[start_val:end_val].strip()

                # Убираем кавычки, если есть
                value = value.strip('"').strip("'")

                # Разбираем список портов/диапазонов
                if value:
                    parts = [p.strip() for p in value.split(',') if p.strip()]
                    for part in parts:
                        if '-' in part:
                            # Валидация диапазона
                            range_parts = part.split('-')
                            if len(range_parts) == 2 and range_parts[0].isdigit() and range_parts[1].isdigit():
                                ranges.add(part)
                        elif part.isdigit():
                            ports.add(int(part))

                start = idx + 1  # Продолжаем поиск следующего вхождения

        return ports, ranges

    def format_port_list(ports, ranges):
        """Форматирует список портов и диапазонов в строку для windivert"""
        if not ports and not ranges:
            return None

        # Сортируем порты по возрастанию
        sorted_ports = sorted(ports)
        # Сортируем диапазоны по начальному порту
        sorted_ranges = sorted(ranges, key=lambda r: int(r.split('-')[0]))

        # Формируем итоговую строку: сначала порты, затем диапазоны
        parts_list = [str(p) for p in sorted_ports]
        parts_list.extend(sorted_ranges)
        return ','.join(parts_list)

    # Собираем ВСЕ правила для анализа (префиксы + основные)
    all_rules_for_analysis = prefix_rules + all_rules

    # Извлекаем порты из ВСЕХ правил
    tcp_ports, tcp_ranges = extract_ports_from_rules(all_rules_for_analysis, 'tcp')
    udp_ports, udp_ranges = extract_ports_from_rules(all_rules_for_analysis, 'udp')

    # Формируем строки портов (или None если нет портов)
    tcp_ports_str = format_port_list(tcp_ports, tcp_ranges)
    udp_ports_str = format_port_list(udp_ports, udp_ranges)

    tcp_ports_value = tcp_ports_str or ""
    udp_ports_value = udp_ports_str or ""
    # --- КОНЕЦ НОВОГО КОДА ---

    lines = []
    lines.append(BATCH_HEADER)
    lines.append(
        BATCH_INFO_TEMPLATE.format(
            cdn_level=args.cdn_level,
            version=VERSION,
            tcp_ports_value=tcp_ports_value,
            udp_ports_value=udp_ports_value,
        )
    )

    # --- MAIN PROCESS (включая STUN) ---
    if all_rules or prefix_rules:
        cmd_main = f'start "GoodbyeZapret: %CONFIG_NAME%" /min "%BIN%{target_exe}" ^\n'

        # Добавляем префиксы (уже с подставленными портами или без аргументов портов)
        for rule in prefix_rules:
            cleaned_rule = fix_zapret_rule(rule)
            cmd_main += f"{cleaned_rule} ^\n"

        # Подготовка индексов фильтровых профилей
        filter_indices = [
            i for i, r in enumerate(all_rules)
            if is_filter_profile(fix_zapret_rule(r))
        ]
        last_filter_index = filter_indices[-1] if filter_indices else -1

        # Добавляем правила
        for i, rule in enumerate(all_rules):
            suffix = " ^" if i < len(all_rules) - 1 else ""
            cleaned_rule = fix_zapret_rule(rule)

            if is_blob_rule(cleaned_rule):
                # blob-аргументы должны идти без --new
                cmd_main += f"{cleaned_rule}{suffix}\n"
            elif is_filter_profile(cleaned_rule):
                # фильтровые: --new только если это не последний filter-профиль
                if i != last_filter_index:
                    cmd_main += f"{cleaned_rule} --new{suffix}\n"
                else:
                    cmd_main += f"{cleaned_rule}{suffix}\n"
            else:
                # все остальные аргументы просто добавляются к профилю без --new
                cmd_main += f"{cleaned_rule}{suffix}\n"

        lines.append(cmd_main)

    lines.append(BATCH_TRAY)
    lines.append(BATCH_PREPARING)

    base_path = get_base_path()
    output_dir = (base_path / OUTPUT_REL_PATH).resolve()
    output_dir.mkdir(parents=True, exist_ok=True)
    out_path = output_dir / OUTPUT_BAT

    try:
        with open(out_path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))
    except Exception as e:
        print(f"REM [ERROR] Could not write batch file: {e}")

    return tcp_ports_value, udp_ports_value

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--engine", default="1", choices=["1", "2"])
    parser.add_argument("--get-limits", action="store_true")

    parser.add_argument("--youtube", default="0")
    parser.add_argument("--youtubegooglevideo", default="0")
    parser.add_argument("--youtubequic", default="0")
    parser.add_argument("--twitch", default="0")
    parser.add_argument("--discord", default="0")
    parser.add_argument("--discordupdate", default="0")
    parser.add_argument("--discordquic", default="0")
    parser.add_argument("--discordmedia", default="0")
    parser.add_argument("--blacklist", default="0")
    parser.add_argument("--cdn", default="0")
    parser.add_argument("--amazontcp", default="0")
    parser.add_argument("--amazonudp", default="0")
    parser.add_argument("--custom", default="0")
    parser.add_argument("--auto", default="0")
    parser.add_argument("--stun", default="0")

    parser.add_argument("--cdn-level", default="base")

    args = parser.parse_args()

    # Загружаем конфиг в зависимости от движка
    data = load_config(args.engine)

    if args.get_limits:
        export_limits(data)
    else:
        tcp_ports_value, udp_ports_value = generate_bat_file(args, data)
        save_user_config(args, tcp_ports_value, udp_ports_value)


if __name__ == "__main__":
    main()
